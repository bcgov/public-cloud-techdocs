# Infrastructure-as-Code (IaC) and CI/CD

Last updated: **{{ git_revision_date_localized }}**

## Overview

!!! question "Planning to deploy across accounts?"

    **Important**: The Tools account does not have network connectivity to the Dev, Test, or Prod VPCs. Cross-account deployments from Tools to other environments are limited to API-based operations only (no private network access). For deployments requiring VPC access, consider running CI/CD pipelines directly within each target account instead of centralizing in Tools.

## AWS LZA limitations and considerations

Take the following into consideration when building your application infrastructure on the AWS Landing Zone Accelerator:

- **Regional constraints**: Only Canada (Central) - `ca-central-1` region is supported
- **Network connectivity**: There is no direct (private) connectivity to the B.C. government network. Applications requiring access to government network data must use public endpoints. **Direct Connect is coming soon** to provide private connectivity.
- **Cross-account network isolation**: The Tools account VPC does not have network connectivity to Dev, Test, or Prod VPCs. Cross-account deployments are limited to AWS API operations only.
- **HTTPS requirement**: Only HTTPS applications are compatible with public endpoints through Amazon API Gateway or Application Load Balancer
- **VPC and subnet management**: VPCs and subnets are managed by the platform and cannot be created or modified by users. Security groups can be created by users, but platform-created security groups with Accelerator tags cannot be modified
- **IAM Users**: IAM Users and their access keys can only be generated by the [IAM User management service](../design-build-deploy/iam-user-service.md), which is created and managed by the Public cloud team. Teams should avoid using IAM Users unless absolutely required, as they add complexity to access management and security.

## Terraform

### Best practices for Terraform in LZA

When using Terraform to deploy infrastructure in the AWS Landing Zone Accelerator, follow these best practices:

#### Provider configuration

Always specify the AWS provider configuration with the Canada Central region:

```terraform
# Define provider
provider "aws" {
  region = "ca-central-1"  # LZA only supports Canada Central
}
```

#### Resource tagging strategy

Apply consistent tags to all resources for organization and management:

```terraform
# Example S3 bucket with proper tagging
resource "aws_s3_bucket" "example_bucket" {
  bucket = "your-unique-bucket-name-${random_id.bucket_suffix.hex}"

  tags = {
    Name        = "ExampleBucket"
    Environment = var.environment
    Project     = var.project_name
    Owner       = var.owner
    CostCenter  = var.cost_center
  }
}

resource "random_id" "bucket_suffix" {
  byte_length = 4
}
```

#### State management

Use remote state storage for team collaboration and state locking:

```terraform
terraform {
  backend "s3" {
    bucket         = "your-terraform-state-bucket"
    key            = "infrastructure/terraform.tfstate"
    region         = "ca-central-1"
    encrypt        = true
    dynamodb_table = "terraform-state-lock"
  }
}
```

#### Using Terraform to create security groups

Security groups can be created by users (platform-created security groups with Accelerator tags cannot be modified). Follow the principle of least privilege:

```terraform
resource "aws_security_group" "web_sg" {
  name_prefix = "web-sg-"
  description = "Security group for web servers"
  vpc_id      = data.aws_vpc.main.id

  ingress {
    description = "HTTPS from anywhere"
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    description = "All outbound traffic"
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name = "web-security-group"
  }

  lifecycle {
    create_before_destroy = true
  }
}
```

## GitHub Actions

If you are using GitHub Actions for your CI/CD pipeline, consider the following best practices:

- Configure [OpenID Connect (OIDC) authentication](#configuring-github-action-oidc-authentication-to-aws) for GitHub Actions to authenticate with AWS.
- **Network limitations**: Remember that the Tools account has no network connectivity to other account VPCs. Use Tools for API-based deployments only, or run pipelines directly in target accounts for VPC-based resources.
- Implement proper secret management using AWS Secrets Manager or Systems Manager Parameter Store.

### Configuring GitHub Action OIDC authentication to AWS

To allow GitHub Actions to securely access AWS accounts in your LZA project set, use OpenID Connect (OIDC) authentication. For detailed guidance, see [GitHub's OIDC documentation](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services) and [AWS IAM OIDC documentation](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_create_oidc.html).

!!! info "Prerequisites"

    OIDC authentication requires that your GitHub repository and AWS accounts are properly configured. Contact the Public cloud team if you need assistance with the initial setup.

Here's how to set it up:

1. **AWS IAM Role Configuration**: Create an IAM role with the necessary permissions and trust policy that allows the GitHub OIDC provider:

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Federated": "arn:aws:iam::YOUR_ACCOUNT_ID:oidc-provider/token.actions.githubusercontent.com"
      },
      "Action": "sts:AssumeRoleWithWebIdentity",
      "Condition": {
        "StringEquals": {
          "token.actions.githubusercontent.com:aud": "sts.amazonaws.com"
        },
        "StringLike": {
          "token.actions.githubusercontent.com:sub": "repo:YOUR_ORG/YOUR_REPO:*"
        }
      }
    }
  ]
}
```

2. **GitHub Workflow Configuration**: Configure your GitHub workflow to use OIDC authentication:

```yaml
name: Deploy to AWS
on:
  push:
    branches: [main]

permissions:
  id-token: write # Required for OIDC
  contents: read # Required for actions/checkout

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::YOUR_ACCOUNT_ID:role/GitHubActionsRole
          role-session-name: GitHubActions
          aws-region: ca-central-1

      - name: Deploy with Terraform
        run: |
          terraform init
          terraform plan
          terraform apply -auto-approve
```

### Multi-account deployment strategies

For deploying across multiple accounts in your project set, consider these patterns. **Important**: The Tools account has no network connectivity to other VPCs, so cross-account deployments are limited to AWS API operations only.

#### Cross-account IAM roles (API deployments only)

Set up cross-account roles that allow your CI/CD pipeline to deploy via AWS APIs to other accounts. This approach works for resources that don't require direct VPC connectivity:

```terraform
# In target accounts (dev, test, prod)
resource "aws_iam_role" "deployment_role" {
  name = "GitHubActionsDeploymentRole"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          AWS = "arn:aws:iam::${var.tools_account_id}:root"
        }
        Condition = {
          StringEquals = {
            "sts:ExternalId" = var.external_id
          }
        }
      }
    ]
  })
}
```

#### Environment-specific workflows (recommended for VPC resources)

For resources requiring VPC access, run CI/CD pipelines directly within each target account. Create separate workflows or jobs for different environments:

```yaml
name: Multi-Environment Deployment
on:
  push:
    branches: [main]

jobs:
  deploy-dev:
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    environment: development
    steps:
      - name: Deploy to Dev
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEV_ROLE_ARN }}
          aws-region: ca-central-1

  deploy-prod:
    if: github.ref == 'refs/heads/main'
    needs: deploy-dev
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Deploy to Prod
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_PROD_ROLE_ARN }}
          aws-region: ca-central-1
```

### Using AWS CodeBuild as a GitHub Action runner

AWS CodeBuild can be used as a GitHub Action runner, providing a secure and scalable way to run CI/CD workflows within your AWS environment. This is particularly useful when you need access to AWS services or resources that aren't available to standard GitHub-hosted runners.

For complete setup instructions, see the [AWS CodeBuild GitHub Actions runner documentation](https://docs.aws.amazon.com/codebuild/latest/userguide/action-runner.html).

#### Benefits of CodeBuild as a GitHub runner

- **Native AWS integration**: Direct access to AWS services without complex authentication
- **Custom environments**: Use custom Docker images with pre-installed tools
- **Scalability**: Automatically scales based on workload demands
- **Security**: Runs within your AWS VPC with proper IAM permissions
- **Cost-effective**: Pay only for compute time used

#### Setting up CodeBuild for GitHub Actions

1. **Create a CodeBuild project configured for GitHub Actions**:

```terraform
resource "aws_codebuild_project" "github_runner" {
  name          = "github-actions-runner"
  description   = "CodeBuild project for GitHub Actions"
  service_role  = aws_iam_role.codebuild_github_role.arn

  artifacts {
    type = "NO_ARTIFACTS"
  }

  environment {
    compute_type = "BUILD_GENERAL1_MEDIUM"
    image        = "aws/codebuild/amazonlinux2-x86_64-standard:5.0"
    type         = "LINUX_CONTAINER"
  }

  source {
    type     = "GITHUB"
    location = "https://github.com/your-org/your-repo.git"
    # Buildspec is ignored for GitHub Actions runners
  }

  # Note: VPC configuration only provides access to the same account's VPC
  # Tools account cannot access Dev/Test/Prod VPCs via private networking
  vpc_config {
    vpc_id = data.aws_vpc.tools.id  # Only Tools account VPC
    subnets = [
      data.aws_subnet.tools_private_1.id,
      data.aws_subnet.tools_private_2.id
    ]
    security_group_ids = [aws_security_group.codebuild.id]
  }
}

resource "aws_codebuild_webhook" "github_webhook" {
  project_name = aws_codebuild_project.github_runner.name
  build_type   = "BUILD"

  filter_group {
    filter {
      type    = "EVENT"
      pattern = "WORKFLOW_JOB_QUEUED"
    }
  }
}
```

!!! note "Buildspec is ignored"

    When using CodeBuild as a GitHub Actions runner, any buildspec file is **automatically ignored**. CodeBuild overrides it with commands to set up the self-hosted runner. You can optionally enable buildspec usage by adding `buildspec-override:true` as a label in your workflow. See [buildspec override documentation](https://docs.aws.amazon.com/codebuild/latest/userguide/action-runner.html#action-runner-buildspec-override) for more details.

2. **GitHub workflow configuration**:

```yaml
name: Deploy with CodeBuild Runner
on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: codebuild-github-actions-runner-${{ github.run_id }}-${{ github.run_attempt }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Deploy infrastructure
        run: |
          terraform init
          terraform plan
          terraform apply -auto-approve
        env:
          AWS_REGION: ca-central-1
```

#### Advanced configuration options

You can override environment settings directly in your workflow labels. For all supported images and compute types, see [CodeBuild compute images documentation](https://docs.aws.amazon.com/codebuild/latest/userguide/action-runner-buildenv.html):

```yaml
name: High-Performance Build
on:
  push:
    branches: [main]

jobs:
  build:
    runs-on:
      - codebuild-github-actions-runner-${{ github.run_id }}-${{ github.run_attempt }}
      - image:linux-5.0
      - instance-size:large
    steps:
      - run: echo "Running on large instance with Amazon Linux 2023"
```

Or use buildspec commands for setup tasks:

```yaml
name: Build with Custom Setup
on:
  push:
    branches: [main]

jobs:
  build:
    runs-on:
      - codebuild-github-actions-runner-${{ github.run_id }}-${{ github.run_attempt }}
      - buildspec-override:true
    steps:
      - run: echo "GitHub Actions steps run here"
```

#### Required IAM permissions for CodeBuild GitHub runner

```terraform
resource "aws_iam_role" "codebuild_github_role" {
  name = "codebuild-github-actions-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "codebuild.amazonaws.com"
        }
      }
    ]
  })
}

resource "aws_iam_role_policy" "codebuild_github_policy" {
  role = aws_iam_role.codebuild_github_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "logs:CreateLogGroup",
          "logs:CreateLogStream",
          "logs:PutLogEvents",
          "ec2:CreateNetworkInterface",
          "ec2:DescribeNetworkInterfaces",
          "ec2:DeleteNetworkInterface"
        ]
        Resource = "*"
      }
    ]
  })
}
```

## Local development setup

To facilitate local deployments into AWS from your machine, you'll need the following tools:

### Required tools

1. **Terraform**: Install by following the [official Terraform guide](https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli)
2. **AWS CLI**: Install using the [AWS CLI installation guide](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html)
3. **Visual Studio Code**: Set up using the [VSCode setup guide](https://code.visualstudio.com/docs/setup/setup-overview)

### AWS CLI configuration

Configure AWS CLI to work with your LZA accounts:

1. **Access credentials**: Obtain temporary credentials from the [AWS SSO Portal](https://bcgov.awsapps.com/start/#/?tab=accounts)

2. **Configure AWS CLI with SSO**: See [AWS CLI SSO configuration guide](https://docs.aws.amazon.com/cli/latest/userguide/sso-configure-profile-token.html)

```bash
aws configure sso
```

3. **Or use temporary credentials**: Copy credentials from the SSO portal's "Command line or programmatic access" option

### Example Terraform deployment

Here's a complete example of deploying an S3 bucket with proper configuration:

```terraform
# main.tf
terraform {
  required_version = ">= 1.0"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = "ca-central-1"
}

# Data source to get current account ID
data "aws_caller_identity" "current" {}

# Random suffix for unique naming
resource "random_id" "bucket_suffix" {
  byte_length = 4
}

# S3 bucket with proper configuration
resource "aws_s3_bucket" "example" {
  bucket = "my-app-bucket-${random_id.bucket_suffix.hex}"

  tags = {
    Name        = "ExampleBucket"
    Environment = var.environment
    Project     = var.project_name
    ManagedBy   = "Terraform"
  }
}

# Bucket versioning
resource "aws_s3_bucket_versioning" "example" {
  bucket = aws_s3_bucket.example.id
  versioning_configuration {
    status = "Enabled"
  }
}

# Bucket encryption
resource "aws_s3_bucket_server_side_encryption_configuration" "example" {
  bucket = aws_s3_bucket.example.id

  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm = "AES256"
    }
  }
}

# Variables
variable "environment" {
  description = "Environment name"
  type        = string
  default     = "dev"
}

variable "project_name" {
  description = "Project name"
  type        = string
  default     = "my-project"
}
```

### Deployment steps

1. **Initialize Terraform**:

```bash
terraform init
```

2. **Create execution plan**:

```bash
terraform plan
```

3. **Apply changes**:

```bash
terraform apply
```

4. **Confirm deployment**: Type `yes` when prompted

## AWS-specific CI/CD services

Consider using AWS-native CI/CD services for integrated workflows:

### AWS CodePipeline

Deploy CI/CD pipelines using [AWS CodePipeline](https://docs.aws.amazon.com/codepipeline/) for native AWS integration:

```terraform
resource "aws_codepipeline" "example" {
  name     = "example-pipeline"
  role_arn = aws_iam_role.codepipeline_role.arn

  artifact_store {
    location = aws_s3_bucket.artifacts.bucket
    type     = "S3"
  }

  stage {
    name = "Source"
    action {
      name             = "Source"
      category         = "Source"
      owner            = "AWS"
      provider         = "S3"
      version          = "1"
      output_artifacts = ["source_output"]
    }
  }

  stage {
    name = "Deploy"
    action {
      name            = "Deploy"
      category        = "Deploy"
      owner           = "AWS"
      provider        = "CloudFormation"
      input_artifacts = ["source_output"]
      version         = "1"
    }
  }
}
```

### AWS CodeBuild

Use [AWS CodeBuild](https://docs.aws.amazon.com/codebuild/) for build processes:

```terraform
resource "aws_codebuild_project" "example" {
  name          = "example-build"
  service_role  = aws_iam_role.codebuild_role.arn

  artifacts {
    type = "CODEPIPELINE"
  }

  environment {
    compute_type = "BUILD_GENERAL1_SMALL"
    image        = "aws/codebuild/amazonlinux2-x86_64-standard:3.0"
    type         = "LINUX_CONTAINER"
  }

  source {
    type = "CODEPIPELINE"
    buildspec = "buildspec.yml"
  }
}
```

## Security best practices

### IAM policies and roles

Follow the principle of least privilege when creating [AWS IAM policies](https://docs.aws.amazon.com/iam/):

```terraform
resource "aws_iam_policy" "deployment_policy" {
  name        = "DeploymentPolicy"
  description = "Policy for deployment automation"

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "s3:GetObject",
          "s3:PutObject",
          "s3:DeleteObject"
        ]
        Resource = [
          "${aws_s3_bucket.deployment.arn}/*"
        ]
      }
    ]
  })
}
```

### Secrets management

Use [AWS Secrets Manager](https://docs.aws.amazon.com/secretsmanager/) or [AWS Systems Manager Parameter Store](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-parameter-store.html) for sensitive information:

```terraform
resource "aws_secretsmanager_secret" "db_password" {
  name = "database-password"
  description = "Database password for application"
}

resource "aws_ssm_parameter" "api_key" {
  name  = "/app/api-key"
  type  = "SecureString"
  value = var.api_key
}
```

## Monitoring and observability

Implement comprehensive monitoring for your CI/CD pipelines:

### CloudWatch integration

Use [AWS CloudWatch](https://docs.aws.amazon.com/cloudwatch/) for monitoring and alerting:

```terraform
resource "aws_cloudwatch_log_group" "pipeline_logs" {
  name              = "/aws/codebuild/example-build"
  retention_in_days = 30
}

resource "aws_cloudwatch_metric_alarm" "deployment_failures" {
  alarm_name          = "deployment-failures"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "2"
  metric_name         = "FailedDeployments"
  namespace           = "AWS/CodePipeline"
  period              = "300"
  statistic           = "Sum"
  threshold           = "1"
  alarm_description   = "This metric monitors deployment failures"
}
```

## Getting help and resources

- **Documentation**: Comprehensive guides available in this documentation site
- **Support**: [Public Cloud Service Desk (JSM)](https://citz-do.atlassian.net/servicedesk/customer/portal/3) for technical assistance
- **AWS Documentation**:
  - [AWS CodeBuild User Guide](https://docs.aws.amazon.com/codebuild/latest/userguide/)
  - [AWS CodePipeline User Guide](https://docs.aws.amazon.com/codepipeline/latest/userguide/)
  - [AWS Developer Tools documentation](https://docs.aws.amazon.com/dtconsole/latest/userguide/)
  - [GitHub Actions on AWS CodeBuild](https://docs.aws.amazon.com/codebuild/latest/userguide/action-runner.html)
- **Terraform**: [Terraform AWS Provider documentation](https://registry.terraform.io/providers/hashicorp/aws/latest/docs)
- **AWS SDKs**: [AWS SDKs and Tools documentation](https://aws.amazon.com/developer/tools/)

For more detailed Terraform deployment guidance, see the [comprehensive Terraform tutorial](https://developer.hashicorp.com/terraform/tutorials/aws-get-started/aws-build) and explore our [deployment best practices](../design-build-deploy/deploy-to-the-aws-landing-zone-accelerator.md).
